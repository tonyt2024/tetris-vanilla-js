<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tony's Tetris</title>
  <style>
    body{display:flex;justify-content:center;align-items:center;min-height:100vh;margin:0;background:#111;color:#eee;font-family:system-ui,Segoe UI,Roboto}
    .wrap{display:grid;gap:12px;place-items:center}
    canvas{background:#000;box-shadow:0 10px 30px rgba(0,0,0,.6);border-radius:8px}
    .row{display:flex;gap:12px;align-items:center}
    .btn{padding:.5rem .9rem;border:1px solid #444;border-radius:8px;background:#222;color:#eee;cursor:pointer}
    .btn:hover{background:#2a2a2a}
    .score{font-size:1rem;opacity:.9}
    footer{font-size:.8rem;opacity:.6;margin-top:.25rem}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üß± Tetris</h1>
    <canvas id="board" width="240" height="400"></canvas>
    <div class="row">
      <button class="btn" id="left">‚¨Ö</button>
      <button class="btn" id="rot">‚ü≥</button>
      <button class="btn" id="right">‚û°</button>
      <button class="btn" id="down">‚¨á</button>
      <button class="btn" id="restart">Restart</button>
      <div class="score">Score: <span id="score">0</span></div>
    </div>
    <footer>Keys: ‚Üê ‚Üí ‚Üì rotate: ‚Üë / X</footer>
  </div>
<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const COLS = 10, ROWS = 20, SIZE = 20; // 240x400 => 12px margin each side
const colors = ['#000','#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000'];
const tetrominoes = {
  I:[[1,1,1,1]],
  J:[[2,0,0],[2,2,2]],
  L:[[0,0,3],[3,3,3]],
  O:[[4,4],[4,4]],
  S:[[0,5,5],[5,5,0]],
  T:[[0,6,0],[6,6,6]],
  Z:[[7,7,0],[0,7,7]],
};
function rotate(m){return m[0].map((_,i)=>m.map(r=>r[i]).reverse());}
function randomPiece(){
  const keys=Object.keys(tetrominoes);
  const type=keys[(Math.random()*keys.length)|0];
  return {m: tetrominoes[type].map(r=>r.slice()), x:3, y:0, t:type};
}
const arena = Array.from({length:ROWS},()=>Array(COLS).fill(0));
let piece = randomPiece();
let dropCounter=0, dropInterval=500, last=0, score=0, gameOver=false;

function collide(ar, p){
  for(let y=0;y<p.m.length;y++){
    for(let x=0;x<p.m[y].length;x++){
      if(p.m[y][x]!==0 && (ar[y+p.y]?.[x+p.x]??1) !== 0 && (y+p.y)>=0){
        return true;
      }
    }
  }
  return false;
}
function merge(ar,p){
  p.m.forEach((row,dy)=>row.forEach((v,dx)=>{
    if(v!==0 && p.y+dy>=0) ar[p.y+dy][p.x+dx]=v;
  }));
}
function sweep(){
  let lines=0;
  outer: for(let y=ROWS-1;y>=0;y--){
    for(let x=0;x<COLS;x++) if(arena[y][x]===0) continue outer;
    const row = arena.splice(y,1)[0].fill(0);
    arena.unshift(row); lines++; y++;
  }
  if(lines){ score += [0,40,100,300,1200][lines]; document.getElementById('score').textContent=score; }
}
function drawMatrix(m, off, ghost=false){
  m.forEach((row,y)=>row.forEach((v,x)=>{
    if(v!==0){
      ctx.globalAlpha = ghost? .25:1;
      ctx.fillStyle=colors[v];
      ctx.fillRect((x+off.x)*SIZE,(y+off.y)*SIZE,SIZE-1,SIZE-1);
      ctx.globalAlpha=1;
    }
  }));
}
function draw(){
  ctx.fillStyle='#111';ctx.fillRect(0,0,canvas.width,canvas.height);
  // draw arena
  arena.forEach((row,y)=>row.forEach((v,x)=>{
    if(v){ctx.fillStyle=colors[v];ctx.fillRect(x*SIZE,y*SIZE,SIZE-1,SIZE-1);}
  }));
  // ghost piece
  let g = {m:piece.m,x:piece.x,y:piece.y};
  while(!collide(arena,{m:g.m,x:g.x,y:g.y+1})) g.y++;
  drawMatrix(g.m,{x:g.x,y:g.y},true);
  // active
  drawMatrix(piece.m,{x:piece.x,y:piece.y});
}
function drop(){
  if(gameOver) return;
  piece.y++;
  if(collide(arena,piece)){ piece.y--; merge(arena,piece); sweep(); piece=randomPiece();
    if(collide(arena,piece)){ gameOver=true; alert('Game Over! Score: '+score); }
  }
  dropCounter=0;
}
function move(dir){
  piece.x+=dir;
  if(collide(arena,piece)) piece.x-=dir;
}
function rotatePiece(){
  const m=rotate(piece.m); const oldX=piece.x;
  piece.m=m;
  // wall kick simple
  if(collide(arena,piece)){ piece.x++; if(collide(arena,piece)){ piece.x-=2; if(collide(arena,piece)){ piece.x=oldX; piece.m=rotate(rotate(rotate(m))); } } }
}
function update(t=0){
  const dt=t-last; last=t; dropCounter+=dt;
  if(dropCounter>dropInterval) drop();
  draw(); requestAnimationFrame(update);
}
document.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft') move(-1);
  if(e.key==='ArrowRight') move(1);
  if(e.key==='ArrowDown') drop();
  if(e.key==='ArrowUp' || e.key==='x' || e.key==='X') rotatePiece();
});
document.getElementById('left').onclick=()=>move(-1);
document.getElementById('right').onclick=()=>move(1);
document.getElementById('down').onclick=drop;
document.getElementById('rot').onclick=rotatePiece;
document.getElementById('restart').onclick=()=>location.reload();
update();
</script>
</body>
</html>
